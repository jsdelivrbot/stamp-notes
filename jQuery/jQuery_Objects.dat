 <!--
{{feature: .. Simplicity the art of maximizing the amount of work not done. The Agile Manifesto}}
{{feature-image:http://localhost/CodeIgniter/images/spaceball.jpg}}
{{keywords: CodeIgniter,PHP, CodeIgniter, File helper class}}
{{author:Dr Y Lazarides}}
{{date:8 September 2008}}
{{category: PHP, MVC, Parsers}}
{{snippet:using CodeIgniter's file_helper class}}

-->
<style>.firstHeading{background-color:rgb(239,239,239)}
</style>

###Object

Everything in JavaScript is an {{wi:object}}. The easiest way to create an object is the _object literal_:

{{plain: 
<code class="js">
 var x = &#123;&#125;;
 var y = &#123;
   name: "Pete",
   age: 15
 &#125;</code>
 }}
 
The keys can either be quoted or left un-quoted. Every object in JavaScript is an associative array whose keys are strings. This is an important fact to remember. If the key is left unquoted, JavaScript does not issue an error, but silently does the conversion.

 Because of the popularity of JSON, it is frequent to see the keys of object literals as
double-quoted strings. The quotes are required in order to be valid JSON, but they are
not required in order to be valid JavaScript. Keys in object literals can be expressed in
any of the following three ways:

<div  class="code-block console-wrap"><div class="code code-block">
<code>
var name = 'test';
var o = {};
o = { 
  name : 'Yiannis',
  'surname': 'Lazarides',
  "age": 18
};
assert(o.name == 'Yiannis');
assert(o.surname == 'Lazarides');
assert(o.age == 18);
assert(name == 'test');
assert(typeof o == 'object');
</code>
</div>
<div  class="msg" class="msg" style="white-space:pre;font-family:monospace;line-height:1.3">
</div>
<div class="console"></div>
<button class="eval">Run Code!</button>
<ol class="results"></ol> 
</div>

JavaScript's silent conversion of keys to strings can sometimes create unexpected results. Try guessing the result of the code below, before you run the example.

<div  class="code-block console-wrap"><div class="code code-block">
<code>
var foo = new Object();
var bar = new Object();
var map = new Object();
map[foo] = "foo";
map[bar] = "bar";
log(map[foo]);
var map = {};
</code>
</div>
<div  class="msg" class="msg" style="white-space:pre;font-family:monospace;line-height:1.3">
</div>
<div class="console"></div>
<button class="eval">Run Code!</button>
<ol class="results"></ol> 
</div>

In the example, map does not map foo to "foo" and bar to "bar". When foo
and bar are used as keys for map, they are converted into strings using their respective _toString()_ methods. 

This results in mapping the toString() of foo to "foo" and the
toString() of bar to "bar". Because both foo.toString() and bar.toString() are
"[object Object]", the previous code is equivalent to:

<div  class="code-block console-wrap"><div class="code code-block">
<code>
map['[object Object]'] = 'foo';
map['[object Object]'] = 'bar';
log(map['[object Object]']);
log(map[foo]);
</code>
</div>
<div  class="msg" class="msg" style="white-space:pre;font-family:monospace;line-height:1.3">
</div>
<div class="console"></div>
<button class="eval">Run Code!</button>
<ol class="results"></ol> 
</div>
Therefore, map[bar] = "bar" replaces the mapping of map[foo] = "foo" on the previous
line.

###Ways to Look Up a Value in an Object

There are two ways to look up the value in an object. The dot notation and  the array notation, by passing the key as a string.

<div  class="code-block console-wrap"><div class="code code-block">
<code>
map['[object Object]'] = 'foo';
map['[object Object]'] = 'bar';
log(map['[object Object]']);
log(map[foo]);
</code>
</div>
<div  class="msg" class="msg" style="white-space:pre;font-family:monospace;line-height:1.3">
</div>
<div class="console"></div>
<button class="eval">Run Code!</button>
<ol class="results"></ol> 
</div>

Note that the first approach, "Look up value by name", can be used only when the
name is a valid JavaScript identifier. Consider the example from the previous section
where the key was "[object Object]":

alert(map.[object Object]); // throws a syntax error

This may lead you to believe that it is safer to always look up a value by passing a key
as a string rather than by name. In some libraries like Closure, this turns out not to be the case because of how variable renaming works in the Compiler.

###Other Ways of Creating Object Literals

A new object can be created by using  _new Object()_. Both Object() and Object are valid. 
The first method is equivalent to the syntax used in Java (and other C-style
languages) for creating a new object.
Parentheses are technically optional if no arguments are passed to a
function used with the 'new' operator, though this is generally avoided for clarity and consistency. See also the [mother Object](http://127.0.0.1/CodeIgniter/index.php/Blogs/tutorials/jQuery/Object_mother_object).

When you compare these methods the object literal method, literal meaning you declaring the properties when you are defining the function is the most succinct and is popular by most libraries.

<div  class="code-block console-wrap"><div class="code code-block">
<code>
var Salary = new Object();
var Salary = new Object;
var Salary = {};
</code>
</div>
<div  class="msg" class="msg" style="white-space:pre;font-family:monospace;line-height:1.3">
</div>
<div class="console"></div>
<button class="eval">Run Code!</button>
<ol class="results"></ol> 
</div>








Any JavaScript function can be used to create custom object classes, simply by calling it using the keyword _new_. When called in this way, the special variable _this _inside the function references the new object that is being constructed (it normally refers to the 'current' object, which is usually window, except inside methods). 

{{bulb:The function should not return a value. }}

The following function can be used as demonstrated to create an object of class myobject:

<div  class="code-block console-wrap"><div class="code code-block">
<code>
var leave = function(){
           // return this;
}

leave.prototype.test = 'a test';

l = new leave();
log(l.test);
</code>

</div>

<div  class="msg" class="msg" style="white-space:pre;font-family:monospace;line-height:1.3">
</div>
<div class="console"></div>
<button class="eval">Run Code!</button>
<ol class="results"></ol> 
</div>

<h3 style="border-bottom:1px solid #ececec">The dot notation</h3>

You can write and read properties of an object using the dot notation:

{{plain:
<code class="js">
 y.name // "Pete"
 y.age // 15
 x.name = y.name + " Pan" // "Pete Pan"
 x.age = y.age + 1 // 16 
</code>
}}


####Array Notation

Or you write and read properties using the array notation, which allows you to dynamically choose the property:

{{plain:
 var operations = &#123;
   increase: "++",
   decrease: "--"
 &#125;
 var operation = "increase";
 operations[operation] // "++";
 operations["multiply"] = "*"; // "*"
}}


<h3 class="firstHeading">Iteration</h3>

Iterating over objects is easy with the for-in-loop:

{{plain:
var obj = &#123;  
  name: "Pete",
  age: 15
&#125;
for(key in obj) &#123;
 alert("key is "+[key]+", value is "+obj[key]);
&#125;

}}

{{bulb:the for-in-loop can be spoiled by extending Object.prototype (see Object.prototype is verboten) so take care when using other libraries.}}

jQuery provides a generic each-function to iterate over properties of objects, as well as elements of arrays:

 jQuery.each(obj, function(key, value) {
   console.log("key", key, "value", value);
 });
 
 
The drawback is that the callback is called in the context of each value, therefore you lose the context of your own object if applicable. More on this below at Functions.


<h3 style="border-bottom:1px solid #ececec;padding-bottom:10px;margin-top:15px;line-height:1.5">Boolean default</h3>

An object, no matter if it has properties or not, never defaults to false:

 !{} // false
 
 
<h2 class="firstHeading">Options</h2>

Options in jQuery are plain JavaScript objects. Whenever Options is mentioned as a type, that object and also all of its properties should be optional. There are exceptions where at least one option is required. jQuery's most prominent use of Options is its AJAX-method. Nearly all jQuery plugins provide an Options-based API: They work without any configuration, but allow users to specify whatever customization they need.

Let's look at an example from the form plugin. It allows you to submit a form via AJAX with this simple line of code:

{{plain:
 $("#myform").ajaxForm();
}}
 
In that mode, it uses the form's action-attribute as the AJAX-URL and the form's method-attribute to determine whether to GET or POST the form. You can override both defaults by specifying them as options:

{{plain:

 $("#myform").ajaxForm(&#123;
   url: "mypage.php",
   type: "POST"
 &#125);

}}
 

##Extending the jQuery Option

This is the traditional method for adding plugins.

{{plain:
The following code will merge _settings_ and _options_, modifying settings.

var settings = &#123; validate: false, limit: 5, name: "foo" &#125;
var options = &#123; validate: true, name: "bar" &#125;
jQuery.extend(settings, options);

whereas this one will merge defaults and options, without modifying the defaults.

var empty = &#123;&#125;
var defaults = &#123; validate: false, limit: 5, name: "foo" &#125;;
var options = &#123; validate: true, name: "bar" &#125;;
var settings = $.extend(empty, defaults, options);

}}


##Further Reading

[Good discussion at Yahoo Developer](http://developer.yahoo.com/ypatterns/parent.php?pattern=transition)





                  